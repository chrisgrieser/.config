#!/usr/bin/env zsh

# CONFIG
logpath_on_mac="$HOME/Library/Mobile Documents/com~apple~CloudDocs/Tech/backups/backups-to-external-drives.log"
max_number_of_archives=5
archive_every_x_months=3

function do_backup {
	backup "$HOME/Library/Mobile Documents/com~apple~CloudDocs/" ./iCloud-Folder
	backup "$HOME/RomComs/" ./Homefolder/RomComs
	backup "$HOME/Documents/" ./Homefolder/Documents # iCloud only has symlinks

	# perma-repos
	while read -r line; do
		repo_path=$(echo "$line" | cut -d, -f1 | sed "s|^~|$HOME|")
		basename="$(basename "$repo_path")"
		backup "$repo_path/" "./perma-repos/$basename"
	done < "$HOME/.config/perma-repos.csv"
}

#───────────────────────────────────────────────────────────────────────────────
#───────────────────────────────────────────────────────────────────────────────
# HELPER FUNCTIONS

function _pretty_header() {
	light_fg="\e[1;38;5;255m" # force white
	dark_fg="\e[1;38;5;232m" # force black
	fg=$(defaults read -g AppleInterfaceStyle &> /dev/null && echo "$dark_fg" || echo "$light_fg")
	bg="\e[1;44m"
	[[ "$2" == "special" ]] && bg="\e[1;45m"
	print "$fg$bg $1 \e[0m"
}

errors=""
function backup() {
	local bkp_from="$1"
	local bkp_to="$2"
	bkp_from=$(echo "$bkp_from" | sed -E 's|/?$|/|') # ensure slash at end to sync dirs
	local short_name=${bkp_from/#$HOME/"~"}

	if [[ ! -d "$bkp_from" ]]; then
		errors="$errors\n$short_name does not exist."
		return 1
	fi
	echo
	_pretty_header "Backup: $short_name"
	mkdir -p "$bkp_to"

	rsync --archive --delete --delete-excluded --recursive --progress --human-readable \
		--exclude="*.Trash/" --exclude="*/nvim-data/" --exclude=".DS_Store" \
		"$bkp_from" "$bkp_to" || errors="$errors\nProblems occurred for: $short_name"
}

#───────────────────────────────────────────────────────────────────────────────
# DETERMINE VOLUME

spinner="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
for i in {1..200}; do
	volume=$(df | grep ' /Volumes/' | grep --invert-match '/Volumes/Recovery' | 
		grep --only-matching '/Volumes/.*')
	if [[ $(echo "$volume" | wc -l) -gt 1 ]]; then
		print "\e[1;33mMore than one volume connected.\e[0m"
		return 1
	elif [[ -n "$volume" ]]; then
		break
	fi
	pos=$((i % ${#spinner}))
	printf "\rSearching for volume… %s" "${spinner:$pos:1}"
	sleep 0.2
done
printf "\n"

if [[ -z "$volume" ]]; then
	print "\e[1;33mTimeout, no volume found.\e[0m"
	return 1
else
	_pretty_header "Backup volume: $volume" "special"
fi

#───────────────────────────────────────────────────────────────────────────────
# DO BACKUP

device_name="$(scutil --get ComputerName)"
backup_dest="$volume/Backup_$device_name"
mkdir -p "$backup_dest"
cd "$backup_dest" || return 1

echo -n "Backup: $(date '+%Y-%m-%d %H:%M'), $volume -- " >> "$logpath_on_mac"

# if exiting non-zero or aborting, add the missing line break
trap '[[ "$?" -ne 0 ]] && echo "not completed" >> "$logpath_on_mac"' EXIT

do_backup

#───────────────────────────────────────────────────────────────────────────────
# ARCHIVE OLDER BACKUPS

echo
_pretty_header "Archive of backups" "special"

archive="$volume/older backups"
mkdir -p "$archive"
cd "$archive" || return 1
oldest_backup_date=$(command ls | tail -n1 | cut -d_ -f3) # assumes ISO-8691 & two `_`

oldest_timestamp=0 # no backups yet
[[ -n "$oldest_backup_date" ]] && oldest_timestamp=$(date -j -f "%Y-%m-%d" "$oldest_backup_date" "+%s")

max_age_oldest_archive=$(date -v -${archive_every_x_months}m "+%s")
if [[ -n "$errors" ]]; then
	echo "⚠️ Skipped, since the current backup has errors."
elif [[ "$oldest_timestamp" -ge "$max_age_oldest_archive" ]]; then
	echo "Oldest backup in archive is still recent (less than $archive_every_x_months months old)."
else
	echo "Oldest backup in archive more than $archive_every_x_months months old."
	print "\e[1;32mArchiving current backup via macOS Finder.\e[0m"
	iso_today="$(date "+%Y-%m-%d")"
	archive_name="Backup_${device_name}_$iso_today" # exactly 2 underscores needed

	# copy via macOS Finder to leverage speed of APFS cloning
	osascript <<- EOD &> /dev/null
		set currentBackup to (POSIX file "$backup_dest" as alias)
		set archive to (POSIX file "$archive" as alias)

		tell application "Finder"
			duplicate currentBackup to folder archive
			set name of result to "$archive_name"
		end tell
	EOD

	if [[ ! -d "$archive_name" ]]; then
		errors="$errors\nArchive not created."
		open "$archive"
		return
	fi

	# restrict number of backups
	oldest_backups=$(command ls -r | tail +$((max_number_of_archives + 1)))
	if [[ -n "$oldest_backups" ]]; then
		echo "Removing outdated backup: $oldest_backups"
		echo "$oldest_backups" | xargs -I{} rm -rf "{}"
	fi
fi

#───────────────────────────────────────────────────────────────────────────────
# LOG & NOTIFY

echo
_pretty_header "Report" "special"
if [[ -z "$errors" ]]; then
	print "✅ Backup completed: $volume"
	"$ZDOTDIR/notificator" --title "Backup" --message "✅ completed" --sound "Blow"

	echo "completed: $(date '+%H:%M')" >> "$logpath_on_mac"
	echo "Backup: $(date '+%Y-%m-%d %H:%M')" >> "$backup_dest/last_backup.log"
else
	print "\e[1;31m$errors\e[0m"
	"$ZDOTDIR/notificator" --title "Backup" --message "⚠️ Errors occurred." --sound "Basso"

	echo "had errors: $(date '+%H:%M')" >> "$logpath_on_mac"
fi
