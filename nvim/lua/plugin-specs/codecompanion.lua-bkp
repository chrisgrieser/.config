-- DOCS https://codecompanion.olimorris.dev/
--------------------------------------------------------------------------------

-- CONFIG
-- https://platform.openai.com/docs/models
local adapter = { name = "openai_responses", model = "gpt-5-mini" }
local reasoningEffort = "minimal" -- minimal|low|medium|high https://platform.openai.com/docs/api-reference/responses/create#responses_create-reasoning
local apiKeyFile =
	"$HOME/Library/Mobile Documents/com~apple~CloudDocs/Tech/api-keys/openai-api-key.txt"

local useGitSignsInlineDiff = true
local formatInlineResult = true

--------------------------------------------------------------------------------

local function spinnerNotificationWhileRequest()
	if not package.loaded["snacks"] then return end

	local spinners = { "⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏" }
	local updateIntervalMs = 250

	local timer
	vim.api.nvim_create_autocmd("User", {
		desc = "User: CodeCompanion spinner (start)",
		pattern = "CodeCompanionRequestStarted",
		callback = function(ctx)
			local modelName = ctx.data.adapter.model
			timer = assert(vim.uv.new_timer())
			timer:start(
				0,
				updateIntervalMs,
				vim.schedule_wrap(function()
					local spinner = spinners[math.floor(vim.uv.now() / updateIntervalMs) % #spinners + 1]
					vim.notify(modelName .. " " .. spinner, vim.log.levels.TRACE, {
						title = "CodeCompanion",
						icon = "",
						id = ctx.data.id, -- replaces existing notification when using snacks.notifier
					})
				end)
			)
		end,
	})
	vim.api.nvim_create_autocmd("User", {
		desc = "User: CodeCompanion spinner (stop)",
		pattern = "CodeCompanionRequestFinished",
		callback = function(ctx)
			timer:stop()
			timer:close()
			if ctx.data.status == "success" then
				vim.notify(ctx.data.adapter.model .. " finished ✅", vim.log.levels.TRACE, {
					title = "CodeCompanion",
					icon = "",
					id = ctx.data.id,
				})
			else
				Snacks.notifier.hide(ctx.data.id)
			end
		end,
	})
end

local function postRequestHook()
	vim.api.nvim_create_autocmd("User", {
		desc = "User: Sound when CodeCompanion finished",
		pattern = "CodeCompanionRequestFinished",
		callback = function(ctx)
			if ctx.data.status ~= "success" then return end
			if jit.os ~= "OSX" then return end -- using macOS' `afplay`
			local sound =
				"/System/Library/Components/CoreAudio.component/Contents/SharedSupport/SystemSounds/system/head_gestures_double_shake.caf"
			vim.system { "afplay", "--volume", "0.3", sound }
		end,
	})

	vim.api.nvim_create_autocmd("User", {
		desc = "User: format & show diff when CodeCompanion finished",
		pattern = "CodeCompanionInlineFinished",
		callback = function(ctx)
			local ok, conform = pcall(require, "conform")
			if formatInlineResult then
				if not ok then vim.lsp.buf.format { bufnr = ctx.buf } end
				if ok then conform.format { bufnr = ctx.buf } end
			end
			local ok2, gitsigns = pcall(require, "gitsigns")
			if ok2 and useGitSignsInlineDiff then
				require("gitsigns.config").config.show_deleted = true
				gitsigns.setup { linehl = true, word_diff = true }
			end
		end,
	})
end

local function leaveVisualOnInlineRequest()
	vim.api.nvim_create_autocmd("User", {
		desc = "User: leave visual mode",
		pattern = "CodeCompanionInlineStarted",
		callback = function()
			if vim.fn.mode():lower() ~= "v" then return end
			vim.cmd.normal { vim.fn.mode(), bang = true }
		end,
	})
end

local ccSpec = {
	"olimorris/codecompanion.nvim",
	dependencies = "nvim-lua/plenary.nvim",
	cmd = { "CodeCompanion", "CodeCompanionChat", "CodeCompanionActions" },
	init = function() vim.g.whichkeyAddSpec { "<leader>a", group = " AI" } end,
	config = function(_, opts)
		require("codecompanion").setup(opts)
		leaveVisualOnInlineRequest()
		spinnerNotificationWhileRequest()
		postRequestHook()
	end,
	keys = {
		{ "<leader>ac", "<cmd>CodeCompanionChat toggle<CR>", desc = " Chat (toggle)" },
		-- stylua: ignore
		{ "q", "<cmd>CodeCompanionChat toggle<CR>", ft = "codecompanion", nowait = true, desc = " Close chat" },
		{ "<leader>aa", ":CodeCompanion<CR>", mode = "x", desc = " 󰘎 Prompt" },

		-- stylua: ignore start
		-- needs to be `explain_` to not use the builtin `explain`
		{ "<leader>ae", function() require("codecompanion").prompt("explain_") end, mode = "x", desc = " Explain" },
		{ "<leader>as", function() require("codecompanion").prompt("simplify") end, mode = "x", desc = " Simplify" },
		{ "<leader>ap", function() require("codecompanion").prompt("proofread") end, mode = "x", desc = " Proofread" },
		-- stylua: ignore end
	},
	opts = {
		prompt_library = {
			markdown = {
				dirs = { vim.fn.stdpath("config") .. "/prompts" },
			},
		},
		adapters = {
			http = {
				-- https://github.com/olimorris/codecompanion.nvim/blob/main/lua/codecompanion/adapters/http/openai_responses.lua
				openai_responses = function()
					return require("codecompanion.adapters").extend("openai_responses", {
						env = { api_key = ("cmd:cat %q"):format(apiKeyFile) },
						schema = {
							model = {
								choices = {
									["gpt-5-mini"] = { opts = { can_reason = true } },
									["gpt-5-nano"] = { opts = { can_reason = true } },
								},
							},
							["reasoning.effort"] = { default = reasoningEffort },
							["reasoning.summary"] = { enabled = function() return false end }, -- requires organizational access
						},
					})
				end,
			},
		},
		display = {
			diff = { enabled = false }, -- disabled, since `inline` doesn't handle indents properly
			chat = {
				auto_scroll = false,
				fold_context = true,
				intro_message = "Use `?` for help.",
				window = { opts = { statuscolumn = " " } }, -- padding
			},
		},
		interactions = {
			inline = {
				adapter = adapter,
				keymaps = {
					stop = { modes = { n = "<C-c>" } },
				},
			},
			chat = {
				adapter = adapter,
				keymaps = {
					stop = { modes = { n = "<C-c>" } },
					clear = { modes = { n = "<D-k>", i = "<D-k>" } },
					next_header = { modes = { n = "<C-j>", i = "<C-j>" } },
					previous_header = { modes = { n = "<C-k>", i = "<C-k>" } },
					fold_code = { modes = { n = "zz" } },
					yank_code = { modes = { n = "gy" } }, -- last code block
					debug = { modes = { n = "gd" } },
				},
			},
		},
	},
}
--------------------------------------------------------------------------------
return {
	ccSpec,
	{ -- modifications to render-markdown config (merged via lazy.nvim)
		"MeanderingProgrammer/render-markdown.nvim",
		ft = { "markdown", "codecompanion" },
		opts = {
			file_types = { "markdown", "codecompanion" },
			overrides = {
				filetype = {
					codecompanion = {
						code = { border = "thick", style = "full" },
					},
				},
			},
		},
	},
}
