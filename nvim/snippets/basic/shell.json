{
	"shebang": {
		"prefix": "shebang",
		"body": "#!/usr/bin/env zsh"
	},
	"global variable": {
		"prefix": "global (shellcheck)",
		"body": "\\${${1:global_var}:?}",
		"description": "shellcheck recommends failing if global variable is undefined (SC2054). Useful for example for Alfred Environment Variables."
	},
	"i++": {
		"prefix": "i++",
		"body": "${1:i}=$((${1:i} + 1))"
	},
	"var++": {
		"prefix": "++",
		"body": "=$((${1:i} + 1))"
	},
	"i--": {
		"prefix": "i--",
		"body": "${1:i}=$((${1:i} - 1))"
	},
	"ls → find": {
		"prefix": "ls → find",
		"body": "find . -maxdepth 1 -mindepth 1",
		"description": "shellcheck recommends using find instead of ls for most cases (SC2045)."
	},
	"default arg value": {
		"prefix": "default arg value",
		"body": "${1:input}=${${2:var}-${3:default_value}}"
	},
	"check device name": {
		"prefix": "device name",
		"body": "scutil --get ComputerName | grep -q \"$0\""
	},
	"check if sudo user": {
		"prefix": "check if sudo user",
		"body": "sudo -nv && ${1:some_sudo_action}"
	},
	"check if dark mode (macOS)": {
		"prefix": "check if dark mode (macOS)",
		"body": "defaults read -g AppleInterfaceStyle | grep -q \"Dark\""
	},
	"slice": {
		"prefix": "slice (expansion)",
		"body": "${${1:var}:${2:start}:${3:end}}"
	},
	"substitute": {
		"prefix": "substitute (expansion)",
		"body": "${${1:var}//${2:search}/${3:replace}}",
		"description": "one slash for single substitution, two for global substitution"
	},
	"PATH": {
		"prefix": "PATH",
		"body": "export PATH=/usr/local/lib:/usr/local/bin:/opt/homebrew/bin/:\\$PATH",
		"description": "Extends PATH in a way that homebrew installed CLIs are recognized in ARM and Intel Macs."
	},
	"resolve home": {
		"prefix": "resolve home",
		"body": "${1:path}=\"${${1:path}/#\\~/\\$HOME}\""
	},
	"filename": {
		"prefix": "filename",
		"body": "file_name=$(basename \"$${1:file_path}\")"
	},
	"parent folder": {
		"prefix": "parent folder",
		"body": "$(dirname \"$${1:filepath}\")"
	},
	"extension": {
		"prefix": "get extension",
		"body": "ext=${${1:file_name}##*.}"
	},
	"filename w/o ext": {
		"prefix": "filename w/o ext",
		"body": "${1:file_name}=${${1:file_name}%.*}"
	},
	"directory of script": {
		"prefix": "directory of this script",
		"body": "cd \"$(dirname \"\\$0\")\" || return 1"
	},
	"osascript jxa (run script)": {
		"prefix": [
			"jxa (run script)",
			"osascript -l JavaScript"
		],
		"body": "osascript -l JavaScript \"${1:file}\""
	},
	"osascript applescript (execute)": {
		"prefix": [
			"applescript (execute)",
			"osascript -e"
		],
		"body": "osascript -e '${1:command}'"
	},
	"xargs (for each line)": {
		"prefix": "xargs (for each line)",
		"body": "xargs -I {} ${1:some_cmd} '{}'"
	},
	"find -exec": {
		"prefix": "find -exec",
		"body": "find . $0 -exec open '{}' \\;"
	},
	"safe sourcing": {
		"prefix": "source (safe)",
		"body": "[[ -f \"${1:filepath}\" ]] && source \"${1:filepath}\"",
		"description": "Ensures script does not fail when sourced file does not exist."
	},
	"find & xargs": {
		"prefix": "find & xargs",
		"body": "find . -print0 | xargs -0 -I '{}'"
	},
	"notify (var)": {
		"prefix": "notify (var)",
		"body": "osascript -e \"display notification \\\"\\\" with title \\\"$${1:var}\\\"\""
	},
	"trim whitespace": {
		"prefix": "trim whitespace",
		"body": "${1:text}=$(echo -n \"$${1:text}\" | sed -e 's/^ *//' -e 's/ *$//')"
	},
	"notify (msg)": {
		"prefix": "notify (msg)",
		"body": "osascript -e 'display notification \"\" with title \"${1:msg}\"'"
	},
	"[[ .. ]] && .. ": {
		"prefix": "[[ .. ]] && .. ",
		"body": "[[ $1 ]] && $0"
	},
	"then": {
		"prefix": "then .. fi",
		"body": "then\n\t$0\nfi"
	},
	"ternary": {
		"prefix": "ternary",
		"body": "[[ \"$${1:cond}\" ]] && ${2:var}=\"$${3:one}\" || ${2:var}=\"$${4:two}\""
	},
	"if .. then": {
		"prefix": "if .. then",
		"body": "if [[ \"$${1:var}\" ]]; then\n\t$0\nfi"
	},
	"if .. then .. else": {
		"prefix": "if .. then .. else",
		"body": [
			"if [[ \"$${1:cond}\" ]]; then",
			"\t$0",
			"else",
			"\t",
			"fi"
		]
	},
	"check if installed": {
		"prefix": "check if installed",
		"body": "if ! command -v ${1:cli} &>/dev/null; then print \"\\033[1;33m${1:cli} not installed.\\033[0m\" && return 1; fi\n$0"
	},
	"check if in git repo": {
		"prefix": "check if in git repo",
		"body": "if ! git rev-parse --is-inside-work-tree &>/dev/null ; then print \"\\033[1;33mfile is not ins a git repository.\\033[0m\" && return 1 ; fi"
	},
	"goto git root": {
		"prefix": "goto git root",
		"body": "cd \"$(git rev-parse --show-toplevel)\""
	},
	"awk (get field)": {
		"prefix": "awk (field)",
		"body": "awk '{ print $${1:1} }'",
		"description": "Retrieve a field from the piped in string, with whitespace as the default field delimiter. `$n` means that the nth field will be used."
	},
	"sed (replacement)": {
		"prefix": "sed (replacement)",
		"body": "sed -E 's/${1:pattern}/${2:replacement}/g'"
	},
	"input (stdin or $1)": {
		"prefix": "input (stdin or $1)",
		"body": [
			"if [[ $# -eq 0 ]]; then",
			"\tinput=$(< /dev/stdin)",
			"else",
			"\tinput=\"$1\"",
			"fi"
		],
		"description": "reads either from STDIN or $1. stdin may have unescaped newlines, which have to be removed, e.g. via `tr -d '\n'`."
	},
	"stdin": {
		"prefix": "stdin",
		"body": "stdin=$(< /dev/stdin)",
		"description": "$(cat) also works. See https://stackoverflow.com/questions/32363887/in-a-bash-function-how-do-i-get-stdin-into-a-variable"
	},
	"stderr (pipe)": {
		"prefix": "stderr (pipe)",
		"body": "2>&1"
	},
	"null (pipe)": {
		"prefix": "null (pipe)",
		"body": "&>/dev/null"
	},
	"urlEncode": {
		"prefix": "urlEncode",
		"body": "osascript -l JavaScript -e \"encodeURIComponent('${1:text}')\""
	},
	"plist: extract key": {
		"prefix": "plist: extract key",
		"body": "plutil -extract name.childkey xml1 -o - example.plist | sed -n 4p | cut -d'>' -f2 | cut -d'<' -f1"
	},
	"check if process is running": {
		"prefix": "check if process is running",
		"body": "pgrep -xq \"${1:process}\" && $0"
	},
	"quicklook": {
		"prefix": "quicklook",
		"body": "qlmanage -p \"${1:filepath}\"",
		"description": "QuickLook the file. MacOS only."
	},
	"elseif": {
		"prefix": "elseif",
		"body": "elif [[ ${1:condition} ]]; then\n\t${0}",
		"description": "Add an elseif to an if statement."
	},
	"for .. in": {
		"prefix": "for .. in",
		"body": "for ${1:VAR} in ${0:LIST}\ndo\n\techo \"\\$${1:VAR}\"\ndone\n",
		"description": "for loop in list"
	},
	"today (ISO date)": {
		"prefix": ["today (ISO date)", "now"],
		"body": "${1:now}=$(date +\"%Y-%m-%d %H:%M:%S\")"
	},
	"for each line (in file)": {
		"prefix": "for each line (in file)",
		"body": [
			"sed '/^$/d' \"${1:filepath}\" | while read -r ${2:line}; do",
			"\techo$0 \"$${2:line}\"",
			"done"
		]
	},
	"play sound": {
		"prefix": [
			"play sound",
			"audio",
			"afplay"
		],
		"body": "afplay \"/System/Library/Sounds/${1|Basso,Blow,Bottle,Frog,Funk,Glass,Hero,Morse,Ping,Pop,Purr,Sosumi,Submarine,Tink|}.aiff\" &",
		"description": "Running in the background to not block during sound playing"
	},
	"while": {
		"prefix": "while",
		"body": "while [[ ${1:condition} ]]; do\n\t${0}\ndone\n",
		"description": "A while loop by condition."
	},
	"wait until app running": {
		"prefix": "wait until app running",
		"body": "while ! pgrep -xq \"${1:app_name}\"; do sleep 0.1; done"
	},
	"wait until app terminated": {
		"prefix": "wait until app terminated",
		"body": "while pgrep -xq \"${1:app_name}\"; do sleep 0.1; done"
	},
	"restart app": {
		"prefix": "restart app",
		"body": [
			"killall \"${1:app_name}\"",
			"while pgrep -xq \"${1:app_name}\"; do sleep 0.1; done",
			"open -a \"${1:app_name}\""
		],
		"description": "safely restart app, avoiding race condition"
	},
	"function": {
		"prefix": "function",
		"body": "function ${1:name}() {\n\t${0}\n}"
	},
	"switch case": {
		"prefix": "switch case",
		"body": [
			"case $${bar} in",
			"\"one\" | \"two\")",
			"\techo \"foo\"",
			"\t;;",
			"\"three\")",
			"\techo \"bar\"",
			"\t;;",
			"*)",
			"\techo \"default\"",
			"\t;;",
			"esac"
		],
		"description": "A case command first expands word, and tries to match it against each pattern in turn."
	},
	"reset color": {
		"prefix": "reset color",
		"body": "\\033[0m"
	},
	"black": {
		"prefix": "black",
		"body": "\\033[1;30m"
	},
	"red": {
		"prefix": "red",
		"body": "\\033[1;31m"
	},
	"green": {
		"prefix": "green",
		"body": "\\033[1;32m"
	},
	"yellow": {
		"prefix": "yellow",
		"body": "\\033[1;33m"
	},
	"blue": {
		"prefix": "blue",
		"body": "\\033[1;34m"
	},
	"magenta": {
		"prefix": ["magenta", "purple"],
		"body": "\\033[1;35m"
	},
	"cyan": {
		"prefix": "cyan",
		"body": "\\033[1;36m"
	},
	"white": {
		"prefix": "white",
		"body": "\\033[1;37m"
	},
	"black bg": {
		"prefix": "black bg",
		"body": "\\033[1;40m"
	},
	"red bg": {
		"prefix": "red bg",
		"body": "\\033[1;41m"
	},
	"green bg": {
		"prefix": "green bg",
		"body": "\\033[1;42m"
	},
	"yellow bg": {
		"prefix": "yellow bg",
		"body": "\\033[1;43m"
	},
	"blue bg": {
		"prefix": "blue bg",
		"body": "\\033[1;44m"
	},
	"magenta bg": {
		"prefix": ["magenta bg", "purple bg"],
		"body": "\\033[1;45m"
	},
	"cyan bg": {
		"prefix": "cyan bg",
		"body": "\\033[1;46m"
	},
	"white bg": {
		"prefix": "",
		"body": "\\033[1;47m"
	}
}
