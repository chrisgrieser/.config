{
	"replace /gm": {
		"prefix": "replace /gm",
		"body": "replace(/${1:regexp}/gm, \"$2\");"
	},
	"replace": {
		"prefix": "replace",
		"body": "replace(/${1:regexp}/, \"$2\");"
	},
	"JSdoc type": {
		"prefix": "JSdoc type",
		"body": "/** @type{${1|Array.<number>,Array.<string>|}} */"
	},
	"ignore (prettier)": {
		"prefix": "ignore (prettier)",
		"body": "// prettier-ignore",
		"description": "Ignores the next block of code."
	},
	"ignore (rome formatter)": {
		"prefix": "ignore (rome formatter)",
		"body": "// rome-ignore format",
		"description": "Ignores the next block of code."
	},
	"ignore (tsignore)": {
		"prefix": "ignore (tsignore)",
		"body": "// @ts-ignore"
	},
	"globals (eslint)": {
		"prefix": "globals (eslint)",
		"body": "/* global ${1:var} */"
	},
	"fall-through (switch, eslint)": {
		"prefix": "fall through (switch, eslint)",
		"body": "// falls through",
		"description": "This comment indicates that a fallthrough in a switch statement is intentional and disables the respective eslint warning. See: https://eslint.org/docs/latest/rules/no-fallthrough"
	},
	"for (i++)": {
		"prefix": "for (i++)",
		"body": ["for (let i = 0; i < ${1:array}.length; i++) {", "\tconst ${2:element} = ${1:array}[i];", "\t$0", "}"]
	},
	"for (i--)": {
		"prefix": "for (i--)",
		"body": [
			"for (let i = ${1:array}.length - 1; i >= 0; i--) {",
			"\tconst ${2:element} = ${1:array}[i];",
			"\t$0",
			"}"
		]
	},
	".forEach": {
		"prefix": "forEach =>",
		"body": ["forEach(${1:item} => {", "\t$0", "});"]
	},
	".map (array, complex)": {
		"prefix": "map (array, complex)",
		"body": ["map(${1:item} => {", "\t$0", "\treturn ${1:item};", "})"]
	},
	"map (array)": {
		"prefix": "map (array)",
		"body": "map(${1:item} => ${1:item}$0)"
	},
	"filter (array)": {
		"prefix": "filter (array)",
		"body": "filter(${1:item} => ${1:item})"
	},
	"sort (array)": {
		"prefix": "sort (array)",
		"body": ["sort((a, b) => {", "\treturn ${1:b - a};", "})"],
		"description": "Sort Array with basic a-b-comparator function"
	},
	"unique items": {
		"prefix": "unique items",
		"body": "${1:arr} = [...new Set(${2:arr})];"
	},
	"today's date": {
		"prefix": ["today", "date"],
		"body": "const today = new Date();"
	},
	"tomorrow's date": {
		"prefix": ["tomorrow", "date"],
		"body": ["const tomorrow = new Date();", "tomorrow.setDate(tomorrow.getDate() + 1);"]
	},
	"today as ISO 8601 string": {
		"prefix": "ISO date",
		"body": "new Date().toISOString().slice(0, 10);"
	},
	"for .. in (object-key)": {
		"prefix": "for .. in (object-key)",
		"body": [
			"for (const ${1:key} in ${2:object}) {",
			"\tif (${2:object}.hasOwnProperty(${1:key})) {",
			"\t\tconst ${3:element} = ${2:object}[${1:key}];",
			"\t\t$0",
			"\t}",
			"}"
		]
	},
	"for .. of (array)": {
		"prefix": "for .. of (array)",
		"body": ["for (const ${1:iterator} of ${2:object}) {", "\t$0", "}"]
	},
	"if ..": {
		"prefix": "if",
		"body": ["if (${1:condition}) {", "\t$0", "}"]
	},
	"if .. else": {
		"prefix": "if .. else",
		"body": ["if (${1:condition}) {", "\t$0", "} else {", "\t", "}"]
	},
	"argv (node)": {
		"prefix": "argv (node)",
		"body": "const argv = process.argv.slice(2);",
		"description": "Arguments from the command line. [0] is the node executable path, [1] the path of the file being executed, making [2] the first positional argument."
	},
	"switch .. case": {
		"prefix": "switch .. case",
		"body": ["switch (${1:key}) {", "\tcase ${2:value}:", "\t\t$0", "\t\tbreak;", "\tdefault:", "\t\tbreak;", "}"]
	},
	"While ..": {
		"prefix": "while ..",
		"body": ["while (${1:condition}) {", "\t$0", "}"]
	},
	"do .. while ..": {
		"prefix": ["do .. while", "repeat until"],
		"body": ["do {", "\t$0", "} while (${1:condition});"]
	},
	"try .. catch": {
		"prefix": "try .. catch",
		"body": ["try {", "\t$0", "} catch (${1:error}) {", "\t", "}"]
	},
	"if (autosnippet)": {
		"prefix": "if ",
		"body": "if ($0)",
		"luasnip": {
			"autotrigger": true
		},
		"description": "Luasnip-specific autosnippet: https://github.com/L3MON4D3/LuaSnip/blob/master/DOC.md#vs-code"
	},
	"Set Timeout Function": {
		"prefix": ["settimeout", "timeout", "delay"],
		"body": ["setTimeout(() => {", "\t$0", "}, ${1:timeoutMs});"]
	}
}
